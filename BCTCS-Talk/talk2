

Computer Science has, from the start, been about automation. Never the less, the problem that is still open is: How to automate automation?
This research focuses on creating better engines and languages for search. Search tasks can be found all over computer science. Searching the right value in a database, searching he solution to a puzzle, the search for the correct weights to a neural network, or even the search for correctly working code; in fact, every problem in computer science eventually turns out to be a search problem.  Let's look at why that is the case using a simple example and then use it to look at the bigger picture.

Sudoku is a well known, sometimes hard to crack puzzle. We have a nine by nine grid, where each variable can be assigned a digit between 1 and 9. A valid solution is, when additionally all rows, all columns and all disjoined 3 by 3 squares contain each digit exactly once. A simple brute force algorithm would now test out all combinations of assignments until one represents a solution. Already for a half assigned grid, this would take millions of years to finish. One part of a smarter solution is easy to visualise.

Let's take a smaller grid for a better overview. We fill a 3 by 3 grid with the digits 1 to 3 such that all rows and all columns have each digit exactly once. The idea of the algorithm is simple: If we can directly see that there is only one possibility for a variable, we assign it, as is the case when both its neighbours are assigned.
Each of the constraints, called "alldiff", now also become an object that we keep track of. These objects observe three variables each and they can get active once they realise that two of their variables are assigned. When that happens, they assign the variable and notify all constraints that also observe this variable to check whether they can get active. For those coming from software engineering, this can be implemented using an observer pattern. This technique will be named "unit propagation" after the similar technique from boolean satisfiability solving, or short, SAT-solving. Now, the only thing that needs checking is if a variable is assigned to two conflicting assignments. In that case, there is no solution, as all assignments were without alternative.
This unit propagation already solves most easy Sudokus. Go ahead, try it out. It does not solve all of them, as we will see later, but the process is fairly simple to implement or model and does quite well in practice.

Now the bigger picture. The grid from the riddle is nothing more than a memory. The indices to the variables become pointer, the variable assignments the contents. We can agree that all programming languages transform memory, so eventually there will have to be rules for when to transform the assignment of one part of the memory into another. For this analogy, we generalise the concept of constraints to just be a tuple of variables or pointers together with a function that, based on a partial assignment of the variables, can deduce the assignment of other variables. Imagine this as a function. Some variables are the addresses of the inputs, others are the addresses of the outputs, and from the assignment of the inputs we can deduce the assignment of the outputs. We will go further on this analogy later, but let's for now assume this to be a sufficiently expressible programming language, transforming memory.

This language comes now with several upsides. The first one is, that the order in which the values are deduced is not fix. It adjusts to the current state of computation. This is, in fact, quite similar to the lazyness principle of functional and logical languages. As you can imagine, it is quite easy to parallelize. Let each constraint be a thread listening to each other via the variables and this language comes with inherit parallelisation. Furthermore: Remember the function analogy from earlier? If we look at the constraints as functions, we not only the the propagation of deduced values in one direction, we even get the deductions of impossible values in the backwards direction. In the analogy of our 3 by 3 grid: if we already know from some constraints that a certain number cannot be the assignment, it is also propagated and only one assignment might be left. This would be analogous to have information flowing from the output of a function back to its input. In classical functional languages, this is quite hard to formulate.
x x x
x X 3    X needs to be 2
x 1 x

As this type of language has so many upsides, let's further generalise the constraints and values to form a turing complete language. First off, assignments can be to arbitrary constants. However, to allow e.g. the assignment to a constraint, there needs to be the possibility to assign to a tuple filled with pointers. The functional programming equivalent would be an algebraic data type, the imparative one a struct or array. What these tuples do is that they introduce an extra level of indirection to a pointer. To address a value in the tuple one needs the address to the tuple itself and then the address to the offset. In C, this is solved using pointer arithmetic, a functional formulation might need additinal fst, snd and so on functions or pointers as tuples or something as a model. In any case, a tuple is just a value that points to multiple other values which then in return can be assigned by just using their addresses.
In order to get new addresses, there needs to be a special introduction instruction for getting a new pointer. This one is a little difficult to model, as assignments e.g. just lay on a certain address, while getting new addresses gives a context sensitive value based on the current state of memory. But as it doesn't matter which pointer is created, as long as it's new, the order of creation does not matter.
The constraints themselves could very well be tables to perform a lookup over. To further compress this, they could be a set of rules of the form pre -> post, say e.g. (a=1,b=2)->(c=3,Â¬d=4), that are interpreted as "if a=1 and b=2 then deduce c=3 and not d=4". Conjuncting a set of these constraints is like having several active constraints on the memory. Dealing with the "new" constraint is similar to the lambda abstraction....
